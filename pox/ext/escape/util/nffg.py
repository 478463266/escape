# Copyright 2015 Balazs Sonkoly, Janos Czentye
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Abstract class and implementation for basic operations with a single NF-FG, such
as building, parsing, processing NF-FG, helper functions, etc.
"""
import networkx
import xml.etree.ElementTree as ET
from networkx.exception import NetworkXError

from nffg_elements import *

try:
  import virtualizer3 as virt3
except ImportError:
  pass

__version__ = "1.0"


class AbstractNFFG(object):
  """
  Abstract class for managing single NF-FG data structure.

  The NF-FG data model is described in YANG. This class provides the
  interfaces with the high level data manipulation functions.
  """

  # NFFG specific functions

  def add_nf (self):
    """
    Add a single NF node to the NF-FG.
    """
    raise NotImplementedError("Not implemented yet!")

  def add_sap (self):
    """
    Add a single SAP node to the NF-FG.
    """
    raise NotImplementedError("Not implemented yet!")

  def add_infra (self):
    """
    Add a single infrastructure node to the NF-FG.
    """
    raise NotImplementedError("Not implemented yet!")

  def add_link (self, src, dst):
    """
    Add a static or dynamic infrastructure link to the NF-FG.

    :param src: source port
    :param dst: destination port
    """
    raise NotImplementedError("Not implemented yet!")

  def add_sglink (self, src, dst):
    """
    Add an SG link to the NF-FG.

    :param src: source port
    :param dst: destination port
    """
    raise NotImplementedError("Not implemented yet!")

  def add_req (self, src, dst):
    """
    Add a requirement link to the NF-FG.

    :param src: source port
    :param dst: destination port
    """
    raise NotImplementedError("Not implemented yet!")

  def add_node (self, node):
    """
    Add a single node to the NF-FG.

    :param node: node object
    """
    raise NotImplementedError("Not implemented yet!")

  def del_node (self, id):
    """
    Remove a single node from the NF-FG.

    :param id: id of the node
    """
    raise NotImplementedError("Not implemented yet!")

  def add_edge (self, src, dst, link):
    """
    Add an edge to the NF-FG.

    :param src: source port
    :param dst: destination port
    :param link: link object
    """
    raise NotImplementedError("Not implemented yet!")

  def del_edge (self, src, dst):
    """
    Remove an edge from the NF-FG.

    :param src: source port
    :param dst: destination port
    """
    raise NotImplementedError("Not implemented yet!")

  # General functions for create/parse/dump/convert NFFG

  @classmethod
  def parse (cls, data):
    """
    General function for parsing data as a new :any::`NFFG` object and return
    with its reference.

    :param data: raw data
    :type data: str
    :return: parsed NFFG as an XML object
    :rtype: Virtualizer
    """
    raise NotImplementedError("Not implemented yet!")

  def dump (self):
    """
    General function for dumping :any::`NFFG` according to its format to
    plain text.

    :return: plain text representation
    :rtype: str
    """
    raise NotImplementedError("Not implemented yet!")


class NFFG(AbstractNFFG):
  """
  Internal NFFG representation based on networkx.
  """
  # Default domain value
  DEFAULT_DOMAIN = NodeInfra.DEFAULT_DOMAIN
  # Infra types
  TYPE_INFRA_SDN_SW = NodeInfra.TYPE_SDN_SWITCH
  TYPE_INFRA_EE = NodeInfra.TYPE_EE
  TYPE_INFRA_STATIC_EE = NodeInfra.TYPE_STATIC_EE
  TYPE_INFRA_BISBIS = NodeInfra.TYPE_BISBIS
  # Node types
  TYPE_INFRA = Node.INFRA
  TYPE_NF = Node.NF
  TYPE_SAP = Node.SAP
  # Link types
  TYPE_LINK_STATIC = Link.STATIC
  TYPE_LINK_DYNAMIC = Link.DYNAMIC
  TYPE_LINK_SG = Link.SG
  TYPE_LINK_REQUIREMENT = Link.REQUIREMENT
  # Operations
  OPERATION_ADD = Element.ADD
  OPERATION_DEL = Element.DEL
  OPERATION_MOD = Element.MOD
  OPERATION_MOV = Element.MOV

  version = __version__

  def __init__ (self, id=None, name=None, version=__version__):
    """
    Init

    :param id: optional NF-FG identifier (generated by default)
    :type id: str or int
    :param name: optional NF-FG name (generated by default)
    :type name: str
    :param version: optional version (default: 1.0)
    :type version: str
    :return: None
    """
    super(NFFG, self).__init__()
    self.network = networkx.MultiDiGraph()
    """:type: networkx.MultiDiGraph"""
    self.id = str(id) if id is not None else str(generate(self))
    self.name = name if name is not None else "NFFG-" + str(self.id)
    self.version = version

  @property
  def nfs (self):
    return (node for id, node in self.network.nodes_iter(data=True) if
            node.type == Node.NF)

  @property
  def saps (self):
    return (node for id, node in self.network.nodes_iter(data=True) if
            node.type == Node.SAP)

  @property
  def infras (self):
    return (node for id, node in self.network.nodes_iter(data=True) if
            node.type == Node.INFRA)

  @property
  def links (self):
    return (link for src, dst, link in self.network.edges_iter(data=True) if
            link.type == Link.STATIC or link.type == Link.DYNAMIC)

  @property
  def sg_hops (self):
    return (link for s, d, link in self.network.edges_iter(data=True) if
            link.type == Link.SG)

  @property
  def reqs (self):
    return (link for s, d, link in self.network.edges_iter(data=True) if
            link.type == Link.REQUIREMENT)

  ##############################################################################
  # dict specific functions
  ##############################################################################

  def __str__ (self):
    return "NFFG(id=%s name=%s, version=%s)" % (
      self.id, self.name, self.version)

  def __repr__ (self):
    return super(NFFG, self).__repr__()

  def __contains__ (self, item):
    """
    Return True if n is a node, False otherwise.
    """
    if isinstance(item, Node):
      item = item.id
    return item in self.network

  def __iter__ (self, data=False):
    """
    Return an iterator over the nodes.

    :param data: If True return a two-tuple of node and node data dictionary
    :type data: bool
    :return: An iterator over nodes.
    """
    return self.network.nodes_iter(data=data)

  def __len__ (self):
    """
    Return the number of nodes.
    """
    return len(self.network)

  def __getitem__ (self, item):
    """
    Return the object given by the id: item.

    :param item: node id
    :return: node object
    """
    return self.network.node[item]

  ##############################################################################
  # Builder design pattern related functions
  ##############################################################################

  def add_node (self, node):
    """
    Add a Node to the structure.

    :param node: a Node object
    :type node: :any:`Node`
    :return: None
    """
    self.network.add_node(node.id)
    self.network.node[node.id] = node

  def del_node (self, node):
    """
    Remove the node from the structure.

    :param node: node id or node object or a port object of the node
    :type node: str or :any:`Node` or :any`Port`
    :return: the actual node is found and removed or not
    :rtype: bool
    """
    try:
      if isinstance(node, Node):
        node = node.id
      elif isinstance(node, Port):
        node = node.node.id
      self.network.remove_node(node)
      return True
    except NetworkXError:
      # There was no node in the graph
      return False

  def add_edge (self, src, dst, link):
    """
    Add an Edge to the structure.

    :param src: source node id or Node object or a Port object
    :type src: str or :any:`Node` or :any`Port`
    :param dst: destination node id or Node object or a Port object
    :type dst: str or :any:`Node` or :any`Port`
    :param link: edge data object
    :type link: :any:`Link`
    :return: None
    """
    if isinstance(src, Node):
      src = src.id
    elif isinstance(src, Port):
      src = src.node.id
    if isinstance(dst, Node):
      dst = dst.id
    elif isinstance(dst, Port):
      dst = dst.node.id
    self.network.add_edge(src, dst, key=link.id)
    self.network[src][dst][link.id] = link

  def del_edge (self, src, dst, id=None):
    """
    Remove the edge(s) between two nodes.

    :param src: source node id or Node object or a Port object
    :type src: str or :any:`Node` or :any`Port`
    :param dst: destination node id or Node object or a Port object
    :type dst: str or :any:`Node` or :any`Port`
    :param id: unique id of the edge (otherwise remove all)
    :type id: str or int
    :return: the actual node is found and removed or not
    :rtype: bool
    """
    try:
      if isinstance(src, Node):
        src = src.id
      elif isinstance(src, Port):
        src = src.node.id
      if isinstance(dst, Node):
        dst = dst.id
      elif isinstance(dst, Port):
        dst = dst.node.id
      if id is not None:
        self.network.remove_edge(src, dst, key=id)
      else:
        self.network[src][dst].clear()
      return True
    except NetworkXError:
      # There was no node in the graph
      return False

  def add_nf (self, nf=None, id=None, name=None, func_type=None, dep_type=None,
              cpu=None, mem=None, storage=None, delay=None, bandwidth=None):
    """
    Add a Network Function to the structure.

    :param nf: add this explicit NF object instead of create one
    :type nf: :any:`NodeNF`
    :param id: optional id
    :type id: str or int
    :param name: optional name
    :type name: str
    :param func_type: functional type (default: "None")
    :type func_type: str
    :param dep_type: deployment type (default: "None")
    :type dep_type: str
    :param cpu: CPU resource
    :type cpu: str or int
    :param mem: memory resource
    :type mem: str or int
    :param storage: storage resource
    :type storage: str or int
    :param delay: delay property of the Node
    :type delay: float or int
    :param bandwidth: bandwidth property of the Node
    :type bandwidth: float or int
    :return: newly created node
    :rtype: :any:`NodeNF`
    """
    if nf is None:
      res = NodeResource(cpu=cpu, mem=mem, storage=storage, delay=delay,
                         bandwidth=bandwidth) if any(
         i is not None for i in (cpu, mem, storage, delay, bandwidth)) else None
      nf = NodeNF(id=id, name=name, func_type=func_type, dep_type=dep_type,
                  res=res)
    self.add_node(nf)
    return nf

  def add_sap (self, sap=None, id=None, name=None):
    """
    Add a Service Access Point to the structure.

    :param sap: add this explicit SAP object instead of create one
    :type sap: :any:`NodeSAP`
    :param id: optional id
    :type id: str or int
    :param name: optional name
    :type name: str
    :return: newly created node
    :rtype: :any:`NodeSAP`
    """
    if sap is None:
      sap = NodeSAP(id=id, name=name)
    self.add_node(sap)
    return sap

  def add_infra (self, infra=None, id=None, name=None, domain=None,
                 infra_type=None, cpu=None, mem=None, storage=None, delay=None,
                 bandwidth=None):
    """
    Add an Infrastructure Node to the structure.

    :param infra: add this explicit Infra object instead of create one
    :type infra: :any:`NodeInfra`
    :param id: optional id
    :type id: str or int
    :param name: optional name
    :type name: str
    :param domain: domain of the Infrastructure Node (default: None)
    :type domain: str
    :param infra_type: type of the Infrastructure Node (default: 0)
    :type infra_type: int or str
    :param cpu: CPU resource
    :type cpu: str or int
    :param mem: memory resource
    :type mem: str or int
    :param storage: storage resource
    :type storage: str or int
    :param delay: delay property of the Node
    :type delay: float or int
    :param bandwidth: bandwidth property of the Node
    :type bandwidth: float or int
    :return: newly created node
    :rtype: :any:`NodeInfra`
    """
    if infra is None:
      res = NodeResource(cpu=cpu, mem=mem, storage=storage, bandwidth=bandwidth,
                         delay=delay) if any(
         i is not None for i in (cpu, mem, storage, delay, bandwidth)) else None
      infra = NodeInfra(id=id, name=name, domain=domain, infra_type=infra_type,
                        res=res)
    self.add_node(infra)
    return infra

  def add_link (self, src_port, dst_port, link=None, id=None, dynamic=False,
                backward=False, delay=None, bandwidth=None):
    """
    Add a Link to the structure.

    :param link: add this explicit Link object instead of create one
    :type link: :any:`EdgeLink`
    :param src_port: source port
    :type src_port: :any:`Port`
    :param dst_port: destination port
    :type dst_port: :any:`Port`
    :param id: optional link id
    :type id: str or int
    :param backward: the link is a backward link compared to an another Link
    :type backward: bool
    :param delay: delay resource
    :type delay: float or int
    :param dynamic: set the link dynamic (default: False)
    :type dynamic: bool
    :param bandwidth: bandwidth resource
    :type bandwidth: float or int
    :return: newly created edge
    :rtype: :any:`EdgeLink`
    """
    if link is None:
      type = Link.DYNAMIC if dynamic else Link.STATIC
      link = EdgeLink(src=src_port, dst=dst_port, type=type, id=id,
                      backward=backward, delay=delay, bandwidth=bandwidth)
    self.add_edge(src_port.node, dst_port.node, link)
    return link

  def add_undirected_link (self, port1, port2, p1p2id=None, p2p1id=None,
                           dynamic=False, delay=None, bandwidth=None):
    """
    Add two Links to the structure, in both directions.

    :param port1: source port
    :type port1: :any:`Port`
    :param port2: destination port
    :type port2: :any:`Port`
    :param p1p2id: optional link id from port1 to port2
    :type p1p2id: str or int
    :param p2p1id: optional link id from port2 to port1
    :type p2p1id: str or int
    :param delay: delay resource of both links
    :type delay: float or int
    :param dynamic: set the link dynamic (default: False)
    :type dynamic: bool
    :param bandwidth: bandwidth resource of both links
    :type bandwidth: float or int
    :return: newly created edge tuple in (p1->p2, p2->p1)
    :rtype: :any:(`EdgeLink`, `EdgeLink`)
    """
    p1p2Link = self.add_link(port1, port2, id=p1p2id, dynamic=dynamic,
                             backward=False, delay=delay, bandwidth=bandwidth)
    p2p1Link = self.add_link(port2, port1, id=p2p1id, dynamic=dynamic,
                             backward=True, delay=delay, bandwidth=bandwidth)
    return p1p2Link, p2p1Link

  def add_sglink (self, src_port, dst_port, hop=None, id=None, flowclass=None,
                  tag_info=None, delay=None, bandwidth=None):
    """
    Add a SD next hop edge to the structure.

    :param hop: add this explicit SG Link object instead of create one
    :type hop: :any:`EdgeSGLink`
    :param src_port: source port
    :type src_port: :any:`Port`
    :param dst_port: destination port
    :type dst_port: :any:`Port`
    :param id: optional link id
    :type id: str or int
    :param flowclass: flowclass of SG next hop link
    :type flowclass: str
    :param tag_info: tag info
    :type tag_info: str
    :param delay: delay requested on link
    :type delay: float
    :param bandwidth: bandwidth requested on link
    :type bandwidth: float
    :return: newly created edge
    :rtype: :any:`EdgeSGLink`
    """
    if hop is None:
      hop = EdgeSGLink(src=src_port, dst=dst_port, id=id, flowclass=flowclass,
                       tag_info=tag_info, bandwidth=bandwidth, delay=delay)
    self.add_edge(src_port.node, dst_port.node, hop)
    return hop

  def add_req (self, src_port, dst_port, req=None, id=None, delay=None,
               bandwidth=None, sg_path=None):
    """
    Add a requirement edge to the structure.

    :param req: add this explicit Requirement Link object instead of create one
    :type req: :any:`EdgeReq`
    :param src_port: source port
    :type src_port: :any:`Port`
    :param dst_port: destination port
    :type dst_port: :any:`Port`
    :param id: optional link id
    :type id: str or int
    :param delay: delay resource
    :type delay: int or float
    :param bandwidth: bandwidth resource
    :type bandwidth: int or float
    :param sg_path: list of ids of sg_links represents end-to-end requirement
    :type sg_path: list or tuple
    :return: newly created edge
    :rtype: :any:`EdgeReq`
    """
    if req is None:
      req = EdgeReq(src=src_port, dst=dst_port, id=id, delay=delay,
                    bandwidth=bandwidth, sg_path=sg_path)
    self.add_edge(src_port.node, dst_port.node, req)
    return req

  def dump (self):
    """
    Convert the NF-FG structure to a NFFGModel format and return the plain
    text representation.

    :return: text representation
    :rtype: str
    """
    # Create the model
    nffg = NFFGModel(id=self.id, name=self.name, version=self.version)
    # Load Infras
    for infra in self.infras:
      nffg.node_infras.append(infra)
    # Load SAPs
    for sap in self.saps:
      nffg.node_saps.append(sap)
    # Load NFs
    for nf in self.nfs:
      nffg.node_nfs.append(nf)
    # Load Links
    for link in self.links:
      nffg.edge_links.append(link)
    # Load SG next hops
    for hop in self.sg_hops:
      nffg.edge_sg_nexthops.append(hop)
    # Load Requirements
    for req in self.reqs:
      nffg.edge_reqs.append(req)
    # Dump
    return nffg.dump()

  @classmethod
  def parse (cls, raw_data):
    """
    Read the given JSON object structure and try to convert to an NF-FG
    representation as an :any:`NFFG`

    :param raw_data: raw NF-FG description as a string
    :type raw_data: str
    :return: the parsed NF-FG representation
    :rtype: :any:`NFFG`
    """
    # Parse text
    model = NFFGModel.parse(raw_data)
    # Create new NFFG
    nffg = NFFG(id=model.id, name=model.name, version=model.version)
    # Load Infras
    for infra in model.node_infras:
      nffg.add_node(infra)
    # Load SAPs
    for sap in model.node_saps:
      nffg.add_node(sap)
    # Load NFs
    for nf in model.node_nfs:
      nffg.add_node(nf)
    # Load Links
    for link in model.edge_links:
      if link.src.node.type == NFFG.TYPE_NF or link.dst.node.type == \
         NFFG.TYPE_NF:
        link.type = str(NFFG.TYPE_LINK_DYNAMIC)
      nffg.add_edge(link.src.node, link.dst.node, link)
    # Load SG next hops
    for hop in model.edge_sg_nexthops:
      nffg.add_edge(hop.src.node, hop.dst.node, hop)
    # Load Requirements
    for req in model.edge_reqs:
      nffg.add_edge(req.src.node, req.dst.node, req)
    return nffg

  ##############################################################################
  # Helper functions
  ##############################################################################

  def duplicate_static_links (self):
    """
    Extend the NFFG model with backward links for STATIC links to fit for the
    orchestration algorithm.

    STATIC links: infra-infra, infra-sap

    :return: NF-FG with the duplicated links for function chaining
    :rtype: :any:`NFFG`
    """
    # Create backward links
    backwards = [EdgeLink(src=link.dst, dst=link.src, id=str(link.id) + "-back",
                          backward=True, delay=link.delay,
                          bandwidth=link.bandwidth) for u, v, link in
                 self.network.edges_iter(data=True) if link.type == Link.STATIC]
    # Add backward links to the NetworkX structure in a separate step to
    # avoid the link reduplication caused by the iterator based for loop
    for link in backwards:
      self.add_edge(src=link.src, dst=link.dst, link=link)
    return self

  def merge_duplicated_links (self):
    """
    Detect duplicated STATIC links which both are connected to the same
    Port/Node and have switched source/destination direction to fit for the
    simplified NFFG dumping.

    Only leaves one of the links, but that's not defined which one.

    :return: NF-FG with the filtered links for function chaining
    :rtype: :any:`NFFG`
    """
    # Collect backward links
    backwards = [(src, dst, key) for src, dst, key, link in
                 self.network.edges_iter(keys=True, data=True) if (
                   link.type == Link.STATIC or link.type == Link.DYNAMIC) and
                 link.backward is True]
    # Delete backwards links
    for link in backwards:
      self.network.remove_edge(*link)
    return self

  def infra_neighbors (self, node_id):
    """
    Return an iterator for the Infra nodes which are neighbours of the given
    node.

    :param node_id: infra node
    :type node_id: :any:`NodeInfra`
    :return: iterator for the list of Infra nodes
    """
    return {self.network.node[id] for id in self.network.neighbors_iter(node_id)
            if self.network.node[id].type == Node.INFRA}

  def running_nfs (self, infra_id):
    """
    Return an iterator for the NodeNFs which are mapped to the given Infra node.

    :params infra_id: infra node identifier
    :type infra_id: :any: `NodeInfra`
    :return: iterator for the currently running NodeNFs
    """
    return {self.network.node[id] for id in
            self.network.neighbors_iter(infra_id) if
            self.network.node[id].type == Node.NF}

  def clear_links (self, link_type):
    """
    Remove every specific Link from the NFFG defined by given ``type``.

    :param link_type: link type defined in :any:`NFFG`
    :return: None
    """
    return self.network.remove_edges_from(
       [(u, v, link.id) for u, v, link in self.network.edges_iter(data=True) if
        link.type == link_type])

  def clear_nodes (self, node_type):
    """
    Remove every specific Node from the NFFG defined by given ``type``.

    :param node_type: node type defined in :any:`NFFG`
    :return: None
    """
    return self.network.remove_nodes_from(
       [id for id, node in self.network.nodes_iter(data=True) if
        node.type == node_type])

  def copy (self):
    """
    Return the deep copy of the NFFG object.

    :return: deep copy
    :rtype: :any:`NFFG`
    """
    copy = NFFG(id=self.id, name=self.name, version=self.version)
    copy.network = self.network.copy()
    return copy

  def generate_id (self):
    """
    Generate a unique id from object memory address.

    :return: generated id
    :rtype: str
    """
    self.id = str(generate(self))
    return self.id


class NFFGToolBox(object):
  """
  Helper functions for NFFG handling.
  """

  @staticmethod
  def merge_domains (base, nffg):
    """
    Merge the given ``nffg`` into the base NFFG.

    :param base: base NFFG object
    :type base: :any:`NFFG`
    :param nffg: updating information
    :type nffg: :any:`NFFG`
    :return: the update base NFFG
    :rtype: :any:`NFFG`
    """
    from copy import deepcopy
    # Copy infras
    print "Merge %s into %s" % (nffg, base)
    for infra in nffg.infras:
      c_infra = base.add_infra(infra=deepcopy(infra))
      print "Copy infra: %s" % c_infra
    # Copy NFs
    for nf in nffg.nfs:
      c_nf = base.add_nf(nf=deepcopy(nf))
      print "Copy nf: %s" % c_nf
    # Copy SAPs
    for sap_id in [s.id for s in nffg.saps]:
      if sap_id in [s.id for s in base.saps]:
        # Found inter-domain SAP
        print "Found Inter-domain SAP: %s" % sap_id
        # Search outgoing links from SAP, should be only one
        b_links = [l for u, v, l in
                   base.network.out_edges_iter([sap_id], data=True)]
        if len(b_links) < 1:
          print "SAP is not connected to any node! Maybe you forget to call " \
                "duplicate_static_links?"
          return
        if 2 < len(b_links):
          print "Inter-domain SAP should have one and only one connection to " \
                "the domain! Using only the first connection."
          continue
        # Get inter-domain port in base NFFG
        domain_port_base = b_links[0].dst
        print "Found inter-domain port: %s" % domain_port_base
        # Search outgoing links from SAP, should be only one
        n_links = [l for u, v, l in
                   nffg.network.out_edges_iter([sap_id], data=True)]
        if len(n_links) < 1:
          print "SAP is not connected to any node! Maybe you forget to call " \
                "duplicate_static_links?"
          return
        if 2 < len(n_links):
          print "Inter-domain SAP should have one and only one connection to " \
                "the domain! Using only the first connection."
          continue
        # Get port and Infra id's in nffg NFFG
        p_id = n_links[0].dst.id
        n_id = n_links[0].dst.node.id
        # Get the inter-domain port from already copied Infra
        domain_port_nffg = base.network.node[n_id].ports[p_id]
        print "Found inter-domain port: %s" % domain_port_nffg
        # Delete both inter-domain SAP and links connected to them
        base.del_node(sap_id)
        nffg.del_node(sap_id)
        print "Add inter-domain connection with delay: %s, bandwidth: %s" % (
          b_links[0].delay, b_links[0].bandwidth)
        # Add the inter-domain links for both ways
        base.add_undirected_link(port1=domain_port_base, port2=domain_port_nffg,
                                 delay=b_links[0].delay,
                                 bandwidth=b_links[0].bandwidth)
      else:
        # Normal SAP --> copy SAP
        c_sap = base.add_sap(sap=deepcopy(nffg.network.node[sap_id]))
        print "Copy SAP: %s" % c_sap
    # Copy remaining links which should be valid
    for u, v, link in nffg.network.edges_iter(data=True):
      src_port = base.network.node[u].ports[link.src.id]
      dst_port = base.network.node[v].ports[link.dst.id]
      c_link = deepcopy(link)
      c_link.src = src_port
      c_link.dst = dst_port
      base.add_link(src_port=src_port, dst_port=dst_port, link=c_link)
      print "Copy Link: %s" % c_link
    # Return the updated NFFG
    return base

  @staticmethod
  def split_domains (nffg):
    """
    Split NFFG object into separate parts based on DOMAIN attribute.

    :param nffg: global resource view (DoV)
    :type nffg: :any:`NFFG`
    :return: splitted parts as list ov domain name, domain part tuples
    :rtype: tuple
    """
    print "Splitting given NFFG: %s" % nffg
    # Define DOMAIN names
    domains = set()
    for infra in nffg.infras:
      domains.add(infra.domain)
    print "Detected domains: %s" % domains

    splitted_parts = []
    # Checks every domain
    for domain in domains:
      # Collect every node which not in the domain
      deletable = set()
      for infra in nffg.infras:
        # Domains representations based on infras
        if infra.domain == domain:
          # Skip current domains infra
          continue
        # Mark the infra as deletable
        deletable.add(infra.id)
        # Look for orphan NF ans SAP nodes which connected to this deletable
        # infra
        for u, v, link in nffg.network.out_edges_iter([infra.id], data=True):
          # Skip Requirement and SG links
          if link.type != NFFG.TYPE_LINK_STATIC and link.type != \
             NFFG.TYPE_LINK_DYNAMIC:
            continue
          if nffg.network.node[v].type == NFFG.TYPE_NF or nffg.network.node[
            v].type == NFFG.TYPE_SAP:
            deletable.add(v)
      # Copy the NFFG
      nffg_part = nffg.copy()
      # Set metadata
      nffg_part.id = domain
      nffg_part.name = domain + "-splitted"
      # Delete needless nodes --> and as a side effect the connected links too
      nffg_part.network.remove_nodes_from(deletable)
      splitted_parts.append((domain, nffg_part))

      # Recreate inter-domain SAP
      for infra in nffg_part.infras:
        for port in infra.ports:
          # Check ports of remained Infra's for SAP ports
          if "port_type:port-sap" in port.properties:
            # Found inter-domain SAP port
            print "Found inter-domain SAP port: %s" % port
            # Create default SAP object attributes
            sap_id, sap_name = None, None
            # Copy optional SAP metadata as special id or name
            for property in port.properties:
              if str(property).startswith("sap:"):
                sap_id = property.split(":", 1)[1]
              if str(property).startswith("name:"):
                sap_name = property.split(":", 1)[1]
            # Add SAP to splitted NFFG
            if sap_id in nffg_part:
              print "%s is already in the splitted NFFG. Skip adding..." % \
                    nffg_part[sap_id]
              continue
            sap = nffg_part.add_sap(id=sap_id, name=sap_name)
            # Add port to SAP port number(id) is identical with the Infra's port
            sap_port = sap.add_port(id=port.id, properties=port.properties[:])
            # Connect SAP to Infra
            nffg_part.add_undirected_link(port1=port, port2=sap_port)
            print "Create inter-domain SAP: %s" % sap

      # Check orphaned or not connected nodes and remove them
      for node_id in nffg_part.network.nodes():
        if len(nffg_part.network.neighbors(node_id)) > 0:
          continue
        print "Found orphaned node: %s! Remove from sliced part." % \
              nffg_part.network.node[node_id]
        nffg_part.network.remove_node(node_id)
    # Return with the splitted parts
    return splitted_parts

  @staticmethod
  def install_domain (virtualizer, nffg):
    """
    Install NFFG part or complete NFFG into given Virtualizer.

    :param virtualizer: Virtualizer object based on ETH's XML/Yang version.
    :param nffg: splitted NFFG (not necessarily in valid syntax)
    :return: modified Virtualizer object
    """
    print "Adapt modification from %s into %s" % (nffg, repr(virtualizer))
    # Check every infra Node
    for infra in nffg.infras:
      # Check in infra is exist in the Virtualizer
      if str(infra.id) not in virtualizer.nodes.node.getKeys():
        print "InfraNode: %s is not in the domain: %s! Skip related " \
              "initiations..."
        continue
      # Check every outgoing edge
      for u, v, link in nffg.network.out_edges_iter([infra.id], data=True):
        # Observe only the NF neighbours
        if link.dst.node.type != NFFG.TYPE_NF:
          continue
        # Check if the NF is exist in the InfraNode
        if str(v) not in virtualizer.nodes[str(u)].NF_instances.node.getKeys():
          # Create NF object
          nf = link.dst.node
          print "Initiate %s on %s" % (nf, infra)
          # Convert Resources to str for XML conversion
          v_nf_cpu = str(nf.resources.cpu) if nf.resources.cpu else None
          v_nf_mem = str(nf.resources.mem) if nf.resources.mem else None
          v_nf_storage = str(
             nf.resources.storage) if nf.resources.storage else None
          # Create Node object for NF
          v_nf = virt3.Node(id=str(nf.id), name=str(nf.name),
                            type=str(nf.functional_type),
                            resources=virt3.Software_resource(cpu=v_nf_cpu,
                                                              mem=v_nf_mem,
                                                              storage=v_nf_storage))
          # Add NF to Infra object
          virtualizer.nodes[str(u)].NF_instances.add(v_nf)
          # Add NF ports
          for port in nffg[v].ports:
            print "Add %s to %s" % (port, nf)
            nf_port = virt3.Port(id=str(port.id), port_type="port-abstract")
            virtualizer.nodes[str(u)].NF_instances[str(v)].ports.add(nf_port)

      # Add flowrules to Virtualizer
      fr_cntr = 0
      # traverse every point in the Infra node
      for port in infra.ports:
        # Check every flowrule
        for flowrule in port.flowrules:

          # Define metadata
          fr_id = "fr" + str(fr_cntr)
          fr_cntr += 1
          fr_pri = str(100)

          # Check if match starts with in_port
          fr = flowrule.match.split(';')
          if fr[0].split('=')[0] != "in_port":
            print "Missing 'in_port' from match. Skip flowrule conversion..."
            continue

          # Check if the src port is a physical or virtual port
          in_port = fr[0].split('=')[1]
          if str(port.id) in virtualizer.nodes[
            str(infra.id)].ports.port.getKeys():
            # Flowrule in_port is a phy port in Infra Node
            in_port = virtualizer.nodes[str(infra.id)].ports[str(port.id)]
          else:
            # in_port is a dynamic port --> search for connected NF's port
            nf_port = [l.dst for u, v, l in
                       nffg.network.out_edges_iter([infra.id], data=True) if
                       l.type == NFFG.TYPE_LINK_DYNAMIC and str(
                          l.src.id) == in_port]
            # There should be only one link between infra and NF
            if len(nf_port) < 1:
              print "NF port is not found for dynamic Infra port: %s defined " \
                    "in match field!" % port
              continue
            nf_port = nf_port[0]
            in_port = virtualizer.nodes[str(infra.id)].NF_instances[
              str(nf_port.node.id)].ports[str(nf_port.id)]

          # Process match field
          match = None
          if len(fr) > 1:
            if fr[1].split('=')[0] == "TAG":
              vlan = int(fr[1].split('=')[1].split('-')[-1])
              if infra.domain == "OPENSTACK":
                match = r"dl_vlan=%s" % format(vlan, '#06x')
              elif infra.domain == "UN":
                match = ET.Element('match')
                vlan_id = ET.SubElement(match, 'vlan_id')
                vlan_id.text = str(vlan)
            elif fr[1].split('=')[0] == "UNTAG":
              if infra.domain == "OPENSTACK":
                match = r"strip_vlan"
              elif infra.domain == "UN":
                match = ET.Element('match')
                ET.SubElement(ET.SubElement(match, 'vlan'), "pop")

          # Check if action starts with outport
          fr = flowrule.action.split(';')
          if fr[0].split('=')[0] != "output":
            print "Missing 'output' from match. Skip flowrule conversion..."
            continue

          # Check if the dst port is a physical or virtual port
          out_port = fr[0].split('=')[1]
          if str(out_port) in virtualizer.nodes[
            str(infra.id)].ports.port.getKeys():
            # Flowrule output is a phy port in Infra Node
            out_port = virtualizer.nodes[str(infra.id)].ports[str(out_port)]
          else:
            # out_port is a dynamic port --> search for connected NF's port
            nf_port = [l.dst for u, v, l in
                       nffg.network.out_edges_iter([infra.id], data=True) if
                       l.type == NFFG.TYPE_LINK_DYNAMIC and str(
                          l.src.id) == out_port]
            if len(nf_port) < 1:
              print "NF port is not found for dynamic Infra port: %s defined " \
                    "in action field!" % port
              continue
            nf_port = nf_port[0]
            out_port = virtualizer.nodes[str(infra.id)].NF_instances[
              str(nf_port.node.id)].ports[str(nf_port.id)]

          # Process action field
          action = None
          if len(fr) > 1:
            if fr[1].split('=')[0] == "TAG":
              vlan = int(fr[1].split('=')[1].split('-')[-1])
              if infra.domain == "OPENSTACK":
                action = r"mod_vlan_vid:%s" % format(vlan, '#06x')
              elif infra.domain == "UN":
                action = ET.Element('match')
                vlan_id = ET.SubElement(action, 'vlan_id')
                vlan_id.text = str(vlan)
            elif fr[1].split('=')[0] == "UNTAG":
              if infra.domain == "OPENSTACK":
                action = r"strip_vlan"
              elif infra.domain == "UN":
                action = ET.Element('match')
                ET.SubElement(ET.SubElement(action, 'vlan'), "pop")

          # Add Flowentry to Virtualizer
          print "Add flowentry: %s" % flowrule
          virtualizer.nodes[str(infra.id)].flowtable.add(
             virt3.Flowentry(id=fr_id, priority=fr_pri, port=in_port,
                             match=match, action=action, out=out_port))

    # Return with modified Virtualizer
    return virtualizer

  @staticmethod
  def _get_output_port_of_TAG_action (TAG, port):
    for fr in port.flowrules:
      actions = fr.action.split(";")
      for action in actions:
        command, param = action.split("=")
        if command == "TAG" and param == TAG:
          for action2 in actions:
            command2, param2 = action2.split("=")
            try:
              param2 = int(param2)
            except ValueError:
              pass
            if command2 == "output":
              return port.node.ports[param2], fr.bandwidth
          else:
            raise RuntimeError("No 'output' action found for flowrule with"
                               " 'TAG' action!")
    # No flowrule with the given tag action found.
    return None, None

  @staticmethod
  def _find_static_link (nffg, port, outbound=True):
    edges_func = None
    link = None
    if outbound:
      edges_func = nffg.network.out_edges_iter
    else:
      edges_func = nffg.network.in_edges_iter
    for i, j, d in edges_func([port.node.id], data=True):
      if d.type == 'STATIC':
        if outbound and port.id == d.src.id:
          if link is not None:
            raise Exception("InfraPort %s has more than one outbound "
                            "STATIC links!")
          link = d
        if not outbound and port.id == d.dst.id:
          if link is not None:
            raise Exception("InfraPort %s has more than one inbound "
                            "STATIC links!")
          link = d
    return link

  @staticmethod
  def _is_port_finishing_flow (TAG, port):
    if port.node.type == 'SAP':
      return True
    for fr in port.flowrules:
      matches = fr.match.split(";")
      for match in matches:
        field, mparam = match.split("=")
        if field == "TAG" and mparam == TAG:
          for action in fr.action.split(";"):
            if action == "UNTAG":
              return True
    return False

  @staticmethod
  def get_TAGs_of_starting_flows (port):
    for fr in port.flowrules:
      for action in fr.action.split(";"):
        command_param = action.split("=")
        if command_param[0] == "TAG":
          yield command_param[1]

  @staticmethod
  def retrieve_mapped_path (TAG, nffg, starting_port):
    """
    Finds the list of links, where the traffic tagged with the given TAG is 
    routed. starting_port is the first port where the tag is put onto the 
    traffic (the outbound dynamic port of the starting VNF of the flow).
    Returns the list of link objects and the corresponding bandwidth value.
    TODO (?): add default 'None' parameter value for starting_port
    , when the function should find where the given TAG is put on the traffic
    """
    edge_list = []
    bandwidth = None
    tag_list = TAG.split("|")
    vnf1 = tag_list[0]
    vnf2 = tag_list[1]
    reqlinkid = NFFGToolBox.try_to_convert(tag_list[2])
    first_link = NFFGToolBox._find_static_link(nffg, starting_port,
                                               outbound=False)
    if first_link is not None:
      if first_link.src.node.type == 'SAP':
        edge_list.append(first_link)
    # if first link is None, it means the flow starts from a DYNAMIC port.
    first_out_port, bandwidth = NFFGToolBox._get_output_port_of_TAG_action(
       TAG, starting_port)
    # if the TAG action couldn't be found in 'starting_port' maybe this link
    # is collocated on this Infra.
    if first_out_port is None:
      if nffg.network.has_edge(vnf1, starting_port.node.id) and \
         nffg.network.has_edge(vnf2, starting_port.node.id):
        for fr in starting_port.flowrules:
          for action in fr.action.split(";"):
            command, param = action.split("=")
            try:
              param = int(param)
              continue
            except ValueError:
              pass
            splitted_portid = param.split("|")
            if command == "output" and len(splitted_portid) == 3:
              # no TAG action was found, so the output port must be a dynamic 
              # port with ID format InfraID|NFID|NFPortID
              infraid, nfid, nfportid = splitted_portid
              try:
                nfportid = int(nfportid)
              except ValueError:
                pass
              # SGHops should be still in the NFFG
              if nfid == vnf2 and nffg.network[vnf1][vnf2][reqlinkid] \
                 .dst.id == nfportid:
                # WARNING!! IF 'starting_port' has 2 flowrules leading to the
                #  same
                # port of 'vnf2', we can't make difference between the 2 
                # collocation flows!! --> Parallel SGHops to AND from the same 
                # ports shouldn't be allowed! BUT otherwise, it is OK.
                return [], fr.bandwidth
      else:
        raise RuntimeError("Neither starting flowrule nor collocation flowrule"
                           " found in the given port for TAG: %s!" % TAG)

    curr_link = NFFGToolBox._find_static_link(nffg, first_out_port)
    edge_list.append(curr_link)
    curr_port = curr_link.dst
    while not NFFGToolBox._is_port_finishing_flow(TAG, curr_port):
      next_link_found = False
      for fr in curr_port.flowrules:
        for match in fr.match.split(";"):
          field, mparam = match.split("=")
          if field == "TAG" and mparam == TAG:
            for action in fr.action.split(";"):
              command, cparam = action.split("=")
              try:
                cparam = int(cparam)
              except ValueError:
                pass
              if command == "output":
                curr_link = NFFGToolBox._find_static_link(nffg,
                                                          curr_port.node.ports[
                                                            cparam])
                edge_list.append(curr_link)
                curr_port = curr_link.dst
                next_link_found = True
                break
          if next_link_found:
            break
        if next_link_found:
          break
      else:
        raise RuntimeError("Finishing flowrule couldn't be found for TAG: %s"
                           % TAG)
    # curr_port is a flow finishing port, let's check whether the next node 
    # would be a SAP
    """
    THIS IS NOT NEEDED CUZ NOW WE ALSO FIND THE LAST LINK IN PREV ITERATION BLOCK
    if nffg.network.node[vnf2].type == 'SAP':
      # we only need to find the last link separately if 'vnf2' is a SAP
      last_link_found = False
      for fr in curr_port.flowrules:
        for match in fr.action.split(";"):
          field_mparam = match.split("=")
          if field_mparam[0] == 'TAG' and field_mparam[1] == TAG:
            for action in fr.action.split(";"):
              action_split = action.split("=")
              if len(action_split) == 2:
                command, cparam = action_split
                if command == "output":
                  last_link = NFFGToolBox._find_static_link(nffg,
                                                            curr_port.node.ports[
                                                              cparam])
                  if last_link is not None:
                    # maybe there could be multiple output commands...
                    if last_link.dst.node.type == 'SAP':
                      edge_list.append(last_link)
                      last_link_found = True
                      break
                  else:
                    raise RuntimeError("No outbound link found for last port "
                                       "of physical path of TAG: %s" % TAG)
          if last_link_found:
            break
        if last_link_found:
          break
    """
    return edge_list, bandwidth

  @staticmethod
  def generate_all_TAGs_of_NFFG (nffg):
    for sg in nffg.sg_links:
      yield "|".join((sg.src.node.id, sg.dst.node.id, sg.id))

  @staticmethod
  def try_to_convert (id):
    converted = id
    try:
      converted = int(id)
    except ValueError:
      pass
    return converted

  @staticmethod
  def retrieve_all_SGHops (nffg):
    """
    Returns a dictionary keyed by (VNFsrc, VNFdst, reqlinkid) tuples
    , data is [PortObjsrc, PortObjdst] list of port 
    objects. It is based exclusively on flowrules.
    # TODO: retrieve bandwidth and latency (these should be the same for a given
    flowrule sequence, because they all represent the same SGHop)
    """
    sg_map = {}
    for d in nffg.infras:
      for p in d.ports:
        for fr in p.flowrules:
          actions = fr.action.split(";")
          matches = fr.match.split(";")
          for action in actions:
            command_param = action.split("=")
            if "TAG=" in fr.match and command_param[0] == "output":
              # it there is also an UNTAG action or the next node is a SAP 
              # then it is an ending flowrule
              ending_port = None
              # let's find which VNF/SAP port object should the SGHop connect
              #  to.
              act_port_id = NFFGToolBox.try_to_convert(command_param[1])
              transit_fr = True
              for link in nffg.links:
                # iterates on STATIC or DYNAMIC links
                if link.src.id == act_port_id and link.src.node.id == p.node.id:
                  if "UNTAG" in actions or link.dst.node.type == 'SAP' :
                    ending_port = link.dst
                    transit_fr = False
                    break
                  else:
                    # It means this is a transit flowrule, we don't need it at 
                    # all, break from the whole action iteration!
                    break
              if transit_fr:
                break
              # we must (surely) encounter flowclass before adding and we don't 
              # want to mess up inclusion testing in sg_map
              flowclass = None
              for match in matches:
                field, mparam = match.split("=")
                if field == "flowclass":
                  flowclass = mparam
                  break
              for match in matches:
                # match is always like: <<field=value>>
                field, mparam = match.split("=")
                if field == "TAG":
                  splitted_tag = mparam.split("|")
                  splitted_tag[2] = NFFGToolBox.try_to_convert(splitted_tag[2])
                  sghop_info = tuple(splitted_tag)
                  if sghop_info in sg_map:
                    sg_map[sghop_info][1] = ending_port
                  else:
                    # the last element is the port object which is used if the 
                    # flowrules sequence of this TAG value only consists of this
                    # flowrule, and there is no starting flowrule for it, so the
                    # other end of the link (finishing in 'p') is the port where
                    # the SGHop was originating
                    sg_map[sghop_info] = [None, ending_port, flowclass, 
                                          fr.bandwidth, fr.delay, p]
            # TAG action and match cannot coexsist in the same flowrule
            elif command_param[0] == "TAG" or "TAG=" in fr.match:
              starting_port = None
              # let's find which SAP/VNF port object does the SGHop 
              # originates from
              transit_fr = True
              tag_info = None
              for link in nffg.links:
                if link.dst.id == p.id and p.node.id == link.dst.node.id:
                  if ("TAG=" in fr.match and link.src.node.type == 'SAP') or \
                     command_param[0] == "TAG":
                    if command_param[0] == "TAG":
                      tag_info = command_param[1]
                    else:
                      # there must be a TAG field in match
                      for match in matches:
                        field, mparam = match.split("=")
                        if field == "TAG":
                          tag_info = mparam
                          break
                    starting_port = link.src
                    transit_fr = False
                    break
                  else:
                    break
              if transit_fr:
                break
              splitted_tag = tag_info.split("|")
              splitted_tag[2] = NFFGToolBox.try_to_convert(splitted_tag[2])
              sghop_info = tuple(splitted_tag)
              flowclass = None
              for match in matches:
                field, mparam = match.split("=")
                if field == "flowclass":
                  flowclass = mparam
                  break
              if sghop_info in sg_map:
                sg_map[sghop_info][0] = starting_port
              else:
                # the last element means similar to the one before, but the 
                # destination port object can be reached from it similarly.
                for a in actions:
                  c_p = a.split("=")
                  if c_p[0] == "output":
                    out_port = NFFGToolBox.try_to_convert(c_p[1])
                    sg_map[sghop_info] = [starting_port, None, flowclass, 
                                          fr.bandwidth, fr.delay,
                                          d.ports[out_port]]
                    break
            elif "UNTAG" not in actions and "TAG=" not in fr.action and \
                 "TAG=" not in fr.match:
              # we know here: action != TAG and  "TAG=" not in fr.match
              # All required SGHop info can be gathered at once from this
              # flowrule. It is either a SAP-SAP flowrule or a collocated.
              from_sap = False
              flowclass = None
              for match in matches:
                field, mparam = match.split("=")
                if field == "flowclass":
                  flowclass = mparam
                  break
              sg_map_value = [None, None, flowclass, fr.bandwidth, fr.delay]
              for link in nffg.links:
                # p.id is surely in the right format as link.dst.id (they 
                # would reach the same string instance...)
                if link.dst.id == p.id and link.dst.node.id == p.node.id:
                  sg_map_value[0] = link.src
                  break
              for action in actions:
                output_comm_param = action.split("=")
                if output_comm_param[0] == "output":
                  out_port_id = NFFGToolBox.try_to_convert(output_comm_param[1])
                  for link in nffg.links:
                    if link.src.id == out_port_id and \
                          link.src.node.id == p.node.id:
                      sg_map_value[1] = link.dst
                      break
                  # as the last resort for retrieving the SGHop identifier
                  # check for SGHop field in flowrule object
                  if fr.hop_id is None:
                    raise RuntimeError("SGHop id couldn't be retrieved from "
                                       "Flowrule object!")
                  sg_map[(sg_map_value[0].node.id, sg_map_value[1].node.id,
                          NFFGToolBox.try_to_convert(fr.hop_id))] = sg_map_value
                  break
              else:
                raise RuntimeError("No 'output' command found in collocation "
                                     "flowrule!")
    # after all flowrules have been processed we have to check if there is 
    # still a None prt object (meaning that flowrule sequence for that TAG 
    # consisted of only one NON-COLLOCATION flowrule)
    for sghop_info in sg_map:
      if sg_map[sghop_info][0] is None and len(sg_map[sghop_info]) == 6:
        # the originating portobject of the th SGHop is missing
        portobj = sg_map[sghop_info][5]
        for link in nffg.links:
          if link.dst.id == portobj.id and link.dst.node.id == portobj.node.id:
            sg_map[sghop_info][0] = link.src
      if sg_map[sghop_info][1] is None and len(sg_map[sghop_info]) == 6:
        # the destination port object of the SGHop is missing
        portobj = sg_map[sghop_info][5]
        for link in nffg.links:
          if link.src.id == portobj.id and link.src.node.id == portobj.node.id:
            sg_map[sghop_info][1] = link.dst
    return sg_map
