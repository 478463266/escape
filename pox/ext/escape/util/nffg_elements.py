# Copyright 2015 Balazs Sonkoly, Janos Czentye
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Classes for handling the elements of the NF-FG data structure
"""

# Types of infrastructure nodes

BISBIS = 0


class Base(object):
  """
  Main base class for common functionality.
  """

  def __init__ (self, ID=None):
    """
    Init.

    :param ID: optional identification (generated by default)
    :type ID: str or int
    :return: None
    """
    super(Base, self).__init__()
    self.id = str(ID) if ID is not None else str(id(self))  # mandatory

  def persist (self):
    """
    Common function to persist the class structure intoa  plain text format.
    """
    raise NotImplementedError()


class NodeResource(Base):
  """
  Class for storing resource information for Nodes.

  YANG: grouping node_resource
  """

  def __init__ (self, cpu=None, mem=None, storage=None, networking=None):
    """
    Init.

    :param cpu: CPU resource
    :type cpu: str or int
    :param mem: memory resource
    :type mem: str or int
    :param storage: storage resource
    :type storage: str or int
    :param networking: networking resource
    :type networking: str or int
    :return: None
    """
    super(NodeResource, self).__init__()
    # container: compute
    self.cpu = cpu
    self.mem = mem
    # container
    self.storage = storage
    self.networking = networking

  def persist (self):
    return {"compute": {"cpu": str(self.cpu), "mem": str(self.mem)},
            "storage": str(self.storage), "networking": str(self.networking)}


class LinkResource(Base):
  """
  Class for storing resource information for edges.

  YANG: grouping link_resource
  """

  def __init__ (self, delay=None, bandwidth=None):
    """
    Init.

    :param delay: delay resource
    :type delay: str or int
    :param bandwidth: bandwidth resource
    :type bandwidth: str or int
    :return: None
    """
    super(LinkResource, self).__init__()
    self.delay = delay
    self.bandwidth = bandwidth

  def persist (self):
    return {"delay": str(self.delay), "bandwidth": str(self.bandwidth)}


class Node(Base):
  """
  Base class for different types of nodes in the NF-FG.
  """

  def __init__ (self, ID=None):
    """
    Init.

    :param ID: optional Node identification (generated by default)
    :type ID: str or int
    :return: None
    """
    super(Node, self).__init__(ID)

  def persist (self):
    raise NotImplementedError()


class Port(Base):
  """
  Class for storing a port of NF or infrastructure Node.
  """

  def __init__ (self, type="port", ID=None):
    """
    Init.

    :param type: initial property of the port a.k.a type (default: "port")
    :type type: str
    :return: None
    """
    super(Port, self).__init__(ID)
    self.property = [str(type), ]  # leaf-list

  def persist (self):
    return {"id": str(self.id),
            "property": [property for property in self.property]}


class NodeNF(Node):
  """
  Network Function (NF) nodes in the graph.
  """

  def __init__ (self, ID=None, name=None, func_type=None, dep_type=None,
       res=None):
    """
    Init.

    :param name: optional name
    :type name: str
    :param func_type: functional type (default: "None")
    :type func_type: str
    :param dep_type: deployment type (default: "None")
    :type dep_type: str
    :param res: NF resources
    :type res: NodeResource
    :return: None
    """
    super(NodeNF, self).__init__(ID)  # mandatory
    self.name = name  # optional
    self.functional_type = str(func_type)  # mandatory
    # container: specification
    self.deployment_type = str(dep_type)
    self.resources = res if res is not None else NodeResource()
    # container
    self.ports = []  # list

  def add_port (self, type=None, ID=None):
    """
    Add a port with the given params to the NF.
    """
    self.ports.append(Port(ID=ID, type=type))

  ##############################################################################
  # Convenient getters/setters/magic functions
  ##############################################################################

  def del_port (self, ID):
    """
    Remove the port with the given id from the NF.
    """
    for p in self.ports:
      if p.id == ID:
        self.ports.remove(p)
        return

  def persist (self):
    return {"id": str(self.id), "name": str(self.name),
            "functional_type": str(self.functional_type),
            "specification": {"deployment_type": str(self.deployment_type),
                              "resources": self.resources.persist()},
            "ports": [port.persist() for port in self.ports]}


class Flowclass(object):
  """
  Class for storing flowclasses (flowrule without action)
  """

  def __init__ (self, match):
    self.match = match


class Flowrule(Flowclass):
  """
  Class for storing flowrules
  """

  def __init__ (self, match, action):
    super(Flowrule, self).__init__(match)
    self.action = action


class NodeSAP(Node):
  """
  Class for SAP nodes in the NF-FG
  """

  def __init__ (self, id, ports, name=None):
    super(NodeSAP, self).__init__(id)
    self.name = name
    self.ports = ports


class NodeInfra(Node):
  """
  Class for infrastructure nodes in the NF-FG
  """

  def __init__ (self, id, resources, ports, name=None, domain=None,
       infra_type=BISBIS):
    super(NodeInfra, self).__init__(id)
    self.name = name
    self.domain = domain
    self.type = infra_type
    self.resources = resources  # ResOfNode
    self.ports = ports


class Edge(object):
  """
  Class for different types of edges in the NF-FG
  """

  def __init__ (self, id, src, dst):
    super(Edge, self).__init__()
    self.id = id
    self.src = src  # (Node, Port) or (node_id, port_id)?
    self.dst = dst  # (Node, Port) or (node_id, port_id)?


class EdgeLink(Edge):
  """
  Class for static and dynamic links in the NF-FG
  """

  def __init__ (self, id, src, dst, resources):
    super(Edge, self).__init__(id, src, dst)
    self.resources = resources  # ResOfEdge


class EdgeSGLink(Edge):
  """
  Class for links of SG
  """

  def __init__ (self, id, src, dst, flowclass):
    super(Edge, self).__init__(id, src, dst)
    self.flowclass = flowclass  # flowrule without action


class EdgeReq(Edge):
  """
  Class for requirements between arbitrary NF modes
  """

  def __init__ (self, id, src, dst, reqs):
    super(Edge, self).__init__(id, src, dst)
    self.reqs = reqs  # ResOfEdge


if __name__ == "__main__":
  nf = NodeNF("nf1", "NF_21", "compressor", "virtual")
  nf.resources.cpu = "10VCPU"
  nf.resources.mem = "100MB"
  nf.add_port("abstract")
  nf.add_port("virtual", "port11")
  import json

  print json.dumps(nf.persist(), indent=2)
