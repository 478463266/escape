# Copyright 2015 Balazs Sonkoly, Janos Czentye
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Classes for handling the elements of the NF-FG data structure
"""
import json
import collections


################################################################################
# ---------- BASE classes of NFFG elements -------------------
################################################################################
import weakref


class Base(object):
  """
  Main base class for NFFG elements. Contains the common functionality.
  """

  def __init__ (self, ID=None, type=None):
    """
    Init.

    :param type: explicit object type both for nodes and edges
    :type type: str
    :param ID: optional identification (generated by default)
    :type ID: str or int
    """
    super(Base, self).__init__()
    self.id = str(ID) if ID is not None else str(id(self))  # mandatory
    self.type = type

  def persist (self):
    """
    Common function to persist the class structure into a plain text format.

    :return: object structure fir to JSON
    :rtype: object
    """
    raise NotImplementedError()


class Node(Base):
  """
  Base class for different types of nodes in the NF-FG.
  """
  # Node type constants:
  # Infrastructure node --> abstract node represents one or more physical node
  INFRA = "INFRA"
  # SAP nodes --> abstract node represents end point/ports of a service
  SAP = "SAP"
  # Network Function (NF) node --> abstract node represents a virtual function
  NF = "NF"

  def __init__ (self, type, ID=None, name=None):
    """
    Init.

    :param type: node type
    :type type: str
    :param ID: optional id
    :type ID: str or int
    :param name: optional name
    :type name: str
    :return: None
    """
    super(Node, self).__init__(ID=ID, type=type)
    self.name = name  # optional
    self.ports = []  # list of Ports

  def add_port (self, properties=None, ID=None):
    """
    Add a port with the given params to the Node.

    :param ID: optional id
    :type ID: str or int
    :param properties: supported properties of the port (one or more as list)
    :type properties: str or iterable(str)
    :return: newly created and stored Port object
    :rtype: :any:`Port`
    """
    port = Port(self, properties=properties, ID=ID)
    self.ports.append(port)
    return port

  def del_port (self, id):
    """
    Remove the port with the given id from the Node.

    :param id: port id
    :type id: int or str
    :return: None
    """
    for p in self.ports:
      if p.id == id:
        self.ports.remove(p)
        return

  def persist (self):
    node = {"id": str(self.id)}
    ports = [port.persist() for port in self.ports]
    if ports:
      node["ports"] = ports
    if self.name is not None:
      node["name"] = str(self.name)
    return node


class Link(Base):
  """
  Base class for different types of edges in the NF-FG.
  """
  # Edge type constants:
  # Static link --> physical link between saps and infras
  STATIC = "STATIC"
  # Dynamic link --> virtual link between nfs and infras created on demand
  DYNAMIC = "DYNAMIC"
  # SG next hop --> virtual link to describe connection between elements in SG
  SG = "SG"
  # Requirement --> virtual link to define constraints between SG elements
  REQUIREMENT = "REQUIREMENT"

  def __init__ (self, src, dst, type, ID=None):
    """
    Init.

    :param src: source port
    :type src: :any:`Port`
    :param dst: destination port
    :type dst: :any:`Port`
    :param type: link type
    :type type: str
    :param ID: optional id
    :type ID: str or int
    :return: None
    """
    super(Link, self).__init__(ID=ID, type=type)
    if not isinstance(src, Port) or not isinstance(dst, Port):
      raise RuntimeError(
        "Link source and destination must be derived from Port!")
    # Reference to src Port object
    self.src = src  # mandatory
    # Reference to dst Port object
    self.dst = dst  # mandatory

  def persist (self):
    return {"src_node": str(self.src.node.id), "src_port": str(self.src.id),
            "dst_node": str(self.dst.node.id), "dst_port": str(self.dst.id)}


################################################################################
# ---------- NODE AND LINK RESOURCES -------------------
################################################################################

class NodeResource(Base):
  """
  Class for storing resource information for Nodes.
  """
  # YANG: grouping node_resource

  def __init__ (self, cpu=None, mem=None, storage=None, networking=None):
    """
    Init.

    :param cpu: CPU resource
    :type cpu: str or int
    :param mem: memory resource
    :type mem: str or int
    :param storage: storage resource
    :type storage: str or int
    :param networking: networking resource
    :type networking: str or int
    :return: None
    """
    super(NodeResource, self).__init__()
    # container: compute
    self.cpu = cpu
    self.mem = mem
    # container
    self.storage = storage
    self.networking = networking

  def persist (self):
    res = {}
    compute = {}
    if self.cpu is not None:
      compute["cpu"] = str(self.cpu)
    if self.mem is not None:
      compute["mem"] = str(self.mem)
    if compute:
      res["compute"] = compute
    if self.storage is not None:
      res["storage"] = str(self.storage)
    if self.networking is not None:
      res["networking"] = str(self.networking)
    return res


class LinkResource(Base):
  """
  Class for storing resource information for edges.
  """
  # YANG: grouping link_resource

  def __init__ (self, delay=None, bandwidth=None):
    """
    Init.

    :param delay: delay resource
    :type delay: str or int
    :param bandwidth: bandwidth resource
    :type bandwidth: str or int
    :return: None
    """
    super(LinkResource, self).__init__()
    self.delay = delay  # optional
    self.bandwidth = bandwidth  # optional

  def persist (self):
    res = {}
    if self.delay is not None:
      res["delay"] = str(self.delay)
    if self.bandwidth is not None:
      res["bandwidth"] = str(self.bandwidth)
    return res


class Flowrule(Base):
  """
  Class for storing a flowrule.
  """

  def __init__ (self, match="*", action=""):
    """
    Init.

    :param match: matching rule
    :type match: str
    :param action: forwarding action
    :type action: str
    :return: None
    """
    super(Flowrule, self).__init__()
    self.match = match  # mandatory
    self.action = action  # mandatory

  def persist (self):
    return {"match": str(self.match), "action": str(self.action)}


class Port(Base):
  """
  Class for storing a port of an NF.
  """

  def __init__ (self, node, properties=None, ID=None):
    """
    Init.

    :param node: container node
    :type node: :any:`Node`
    :param ID: optional id
    :type ID: str or int
    :param properties: supported properties of the port
    :type properties: str or iterable(str)
    :return: None
    """
    super(Port, self).__init__(ID=ID)
    if not isinstance(node, Node):
      raise RuntimeError("Port's container node must be derived from Node!")
    # weakre to avoid circular reference
    self.node = weakref.proxy(node)
    if isinstance(properties, str):
      self.properties = [properties, ]
    elif isinstance(properties, collections.Iterable):
      self.properties = [p for p in properties]
    elif properties is None:
      self.properties = []
    else:
      raise RuntimeError(
        "Port's properties attribute must be iterable or a string!")

  def add_property (self, property):
    """
    Add a property to the port.

    :param property: property
    :type property: str
    :return: list of properties
    :rtype: list
    """
    self.properties.append(property)
    return self.properties

  def del_property (self, property):
    """
    Remove the property from the Port.

    :param property: property
    :type property: str
    :return: None
    """
    self.properties.remove(property)

  def persist (self):
    port = {"id": str(self.id)}
    property = [property for property in self.properties]
    if property:
      port["property"] = property
    return port


class InfraPort(Port):
  """
  Class for storing a port of Infra Node and handles flowrules.
  """

  def __init__ (self, node, properties=None, ID=None):
    """
    Init.

    :param node: container node
    :type node: :any:`Node`
    :param ID: optional id
    :type ID: str or int
    :param properties: supported properties of the port
    :type properties: str or iterable(str)
    :return: None
    """
    super(InfraPort, self).__init__(node, ID, properties)
    self.flowrules = []

  def add_flowrule (self, match, action):
    """
    Add a flowrule with the given params to the port of an Infrastructure Node.

    :param match: matching rule
    :type match: str
    :param action: forwarding action
    :type action: str
    :return: newly created and stored flowrule
    :rtype: :any:`Flowrule`
    """
    flowrule = Flowrule(match=match, action=action)
    self.flowrules.append(flowrule)
    return flowrule

  def del_flowrule (self, match, action):
    """
    Remove the first flowrule with the given parameters from the Port.

    :param match: matching rule
    :type match: str
    :param action: forwarding action
    :type action: str
    :return: None
    """
    for f in self.flowrules:
      if f.match == match and f.action == action:
        self.flowrules.remove(f)
        return

  def persist (self):
    port = super(InfraPort, self).persist()
    flowrules = [f.persist() for f in self.flowrules]
    if flowrules:
      port["flowrules"] = flowrules
    return port


################################################################################
# ------------------------ NF / SAP / INFRASTRUCTURE NODES -------------------
################################################################################

class NodeNF(Node):
  """
  Network Function (NF) nodes in the graph.
  """

  def __init__ (self, ID=None, name=None, func_type=None, dep_type=None,
       res=None):
    """
    Init.

    :param func_type: functional type (default: "None")
    :type func_type: str
    :param dep_type: deployment type (default: "None")
    :type dep_type: str
    :param res: optional NF resources
    :type res: :any:`NodeResource`
    :return: None
    """
    super(NodeNF, self).__init__(ID=ID, type=Node.NF, name=name)
    self.functional_type = func_type  # mandatory
    # container: specification
    self.deployment_type = dep_type
    self.resources = res if res is not None else NodeResource()
    # container

  def persist (self):
    node = super(NodeNF, self).persist()
    if self.functional_type is not None:
      node["functional_type"] = str(self.functional_type)
    specification = {}
    if self.deployment_type is not None:
      specification["deployment_type"] = str(self.deployment_type)
    res = self.resources.persist()
    if res:
      specification["resources"] = res
    if specification:
      node["specification"] = specification
    return node


class NodeSAP(Node):
  """
  Class for SAP nodes in the NF-FG.
  """

  def __init__ (self, ID=None, name=None):
    super(NodeSAP, self).__init__(ID=ID, type=Node.SAP, name=name)


class NodeInfra(Node):
  """
  Class for infrastructure nodes in the NF-FG.
  """
  # Default Infrastructure Node type
  DEFAULT_INFRA_TYPE = 0
  # Default domain type
  DEFAULT_INFRA_DOMAIN = None

  def __init__ (self, ID=None, name=None, domain=DEFAULT_INFRA_DOMAIN,
       infra_type=DEFAULT_INFRA_TYPE, res=None):
    """
    Init.

    :param domain: domain of the Infrastructure Node
    :type domain: str
    :param infra_type: type of the Infrastructure Node
    :type infra_type: int or str
    :param res: optional Infra resources
    :type res: :any:`NodeResource`
    :return: None
    """
    super(NodeInfra, self).__init__(ID=ID, type=Node.INFRA, name=name)
    self.domain = domain
    self.infra_type = infra_type  # mandatory
    self.resources = res if res is not None else NodeResource()

  def add_port (self, properties=None, ID=None):
    """
    Add a port with the given params to the Infrastructure Node.

    :param ID: optional id
    :type ID: str or int
    :param properties: supported properties of the port (one or more as list)
    :type properties: str or iterable(str)
    :return: newly created and stored Port object
    :rtype: :any:`Port`
    """
    port = InfraPort(self, properties=properties, ID=ID)
    self.ports.append(port)
    return port

  def persist (self):
    node = super(NodeInfra, self).persist()
    if self.domain is not None:
      node["domain"] = str(self.domain)
    node["type"] = str(self.infra_type)
    res = self.resources.persist()
    if res:
      node["resources"] = res
    return node


################################################################################
# ---------- SG REQUIREMENTS / SG NEXT_HOPS / INFRASTRUCTURE LINKS -----------
################################################################################


class EdgeLink(Link):
  """
  Class for static and dynamic links in the NF-FG.

  Represent a static or dynamic link.
  """

  def __init__ (self, src, dst, type=Link.STATIC, ID=None, res=None):
    """
    Init.

    :param src: source port
    :type src: :any:`Port`
    :param dst: destination port
    :type dst: :any:`Port`
    :param type: type of the link (default: Link.STATIC)
    :type type: str
    :param ID: optional id
    :type ID: str or int
    :param res: optional link resources
    :type res: :any:`LinkResource`
    :return: None
    """
    super(EdgeLink, self).__init__(src=src, dst=dst, type=type, ID=ID)
    self.resources = res if res is not None else LinkResource()

  def persist (self):
    link = super(EdgeLink, self).persist()
    res = self.resources.persist()
    if res:
      link.update(res)
    return link


class EdgeSGLink(Link):
  """
  Class for links of SG.

  Represent an edge between SG elements.
  """

  def __init__ (self, src, dst, ID=None, flowclass=None):
    """
    Init.

    :param src: source port
    :type src: :any:`Port`
    :param dst: destination port
    :type dst: :any:`Port`
    :param ID: optional id
    :type ID: str or int
    :param flowclass: flowclass of SG next hop link
    :type flowclass: str
    :return: None
    """
    super(EdgeSGLink, self).__init__(src=src, dst=dst, type=Link.SG, ID=ID)
    self.flowclass = flowclass  # flowrule without action

  def persist (self):
    link = super(EdgeSGLink, self).persist()
    if self.flowclass is not None:
      link["flowclass"] = str(self.flowclass)
    return link


class EdgeReq(Link):
  """
  Class for constraint of networking parameters between SG elements.

  Class for requirements between arbitrary NF modes.
  """

  def __init__ (self, src, dst, ID=None, reqs=None):
    """
    Init.

    :param src: source port
    :type src: :any:`Port`
    :param dst: destination port
    :type dst: :any:`Port`
    :param ID: optional id
    :type ID: str or int
    :param reqs: requirements
    :type reqs: :any:`LinkResource`
    :return: None
    """
    super(EdgeReq, self).__init__(src=src, dst=dst, type=Link.REQUIREMENT,
                                  ID=ID)
    self.reqs = reqs if reqs is not None else LinkResource()

  def persist (self):
    link = super(EdgeReq, self).persist()
    req = self.reqs.persist()
    if req:
      link["reqs"] = req
    return link


################################################################################
# --------========== MAIN CONTAINER STARTS HERE =========-------------
################################################################################

class NFFG(Base):
  """
  Container for a single NF-FG.

  Network Function Forwarding Graph (NF-FG) data model.

  .. warning::

    Not fully implemented yet!
  """
  # Default version
  VERSION = "1.0"
  # Namespace
  NAMESPACE = "http://csikor.tmit.bme.hu/netconf/unify/nffg"
  # prefix
  PREFIX = "nffg"
  # Organization
  ORGANIZATION = "BME-TMIT"
  # Description
  DESCRIPTION = "Network Function Forwarding Graph (NF-FG) data model"

  def __init__ (self, ID=None, name=None, version=None):
    """
    Init

    :param ID: optional NF-FG identifier (generated by default)
    :type ID: str or int
    :param name: optional NF-FG name
    :type name: str
    :param version: optional version (default: 1.0)
    :type version: str
    :return: None
    """
    super(NFFG, self).__init__(ID=ID)
    self.id = str(ID) if ID is not None else str(id(self))  # mandatory
    self.name = name
    self.version = str(version) if version is not None else self.VERSION
    self.nfs = []
    self.saps = []
    self.infras = []
    self.links = []
    self.sg_nexts = []
    self.reqs = []

  def persist (self):
    nffg = {"parameters": {"id": self.id, "version": self.version}}
    if self.name is not None:
      nffg["parameters"]["name"] = str(self.name)
    if self.nfs:
      nffg["node_nfs"] = self.nfs
    if self.saps:
      nffg["node_saps"] = self.saps
    if self.infras:
      nffg["node_infras"] = self.infras
    if self.links:
      nffg["edge_links"] = self.links
    if self.sg_nexts:
      nffg["edge_sg_nexthops"] = self.sg_nexts
    if self.reqs:
      nffg["edge_reqs"] = self.reqs
    return nffg

  def dump (self):
    # Generate
    return json.dumps(self.persist(), indent=1)

  def init_from_json (self, json_data):
    """
    Parse the NFFG object from JSON data.

    :param json_data: NF-FG represented in JSON format
    :type json_data: str
    :return: None
    """
    return json.loads(json_data)


if __name__ == "__main__":
  # NF
  nf = NodeNF()
  nf.id = "nf1"
  nf.name = "NetworkFunction1"
  nf.functional_type = "functype1"
  nf.deployment_type = "virtual"
  nf.resources.cpu = "10VCPU"
  nf.resources.mem = "1GB"
  nf.resources.storage = "10GB"
  nf.resources.networking = "2Mbps"
  # nf.add_port("port_nf1", "port1", "virtual", "vlan:1025")
  p1 = nf.add_port(("port1", "virtual", "vlan:1025"), ID="port_nf1")
  # SAP
  sap = NodeSAP()
  sap.id = "sap1"
  sap.name = "sap1"
  p2 = sap.add_port(ID="port_sap")
  # Infra
  infra = NodeInfra()
  infra.id = "infra1"
  infra.name = "BisBis1"
  infra.domain = "virtual"
  infra.resources.cpu = "20VCPU"
  infra.resources.mem = "2GB"
  infra.resources.storage = "20GB"
  infra.resources.networking = "4Mbps"
  p3 = port_infra = infra.add_port(ID="port_infra")
  port_infra.add_flowrule("match123", "action456")
  # Edge link
  edge_link = EdgeLink(p2, p3, ID="link3")
  edge_link.resources.bandwidth = "100Mbps"
  edge_link.resources.delay = "5ms"
  # Edge SG next hop
  edge_sg = EdgeSGLink(p1, p2, ID="link1")
  edge_sg.flowclass = "flowclass1"
  # Edge requirement
  edge_req = EdgeReq(p2, p3)
  edge_req.id = "link2"
  edge_req.reqs.bandwidth = "100Mbps"
  edge_req.reqs.delay = "5ms"
  # Generate
  print json.dumps(nf.persist(), indent=1, sort_keys=True)
  print json.dumps(sap.persist(), indent=1, sort_keys=True)
  print json.dumps(infra.persist(), indent=1, sort_keys=True)
  print json.dumps(edge_link.persist(), indent=1, sort_keys=True)
  print json.dumps(edge_sg.persist(), indent=1, sort_keys=True)
  print json.dumps(edge_req.persist(), indent=1, sort_keys=True)

  nffg = NFFG()
  nffg.name = "NFFG1"
  print nffg.dump()
